---
title: "232 Days of Cowboy Coding"
date: "2026-02-07"
excerpt: "I've been building with AI every day for 232 days. Fourteen repositories, 535 co-authored commits, and a completely different relationship with how work gets done. Here's what I've learned."
readTime: "7 min read"
tags: ["AI Development", "Process", "Lessons Learned"]
draft: false
---

Cowboy coding is a term that Claude taught me. I actually hadn't heard it before, but I think it's fitting.

I've been working with AI since ChatGPT launched in December 2022. Built some GPTs, used it for research, writing, brainstorming. Casual user for most of that time. I tried Devin for a while and wasted way too much money on tokens before realizing it wasn't what I wanted. I had zero interest in the cookie-cutter coding apps that were spreading like wildfire, the Lovables, the Cursors, the V0s. They were too polished, too constrained.

What I wanted was a learning curve.

Claude Code gave me that. It lives in the CLI, moves through my files and folders, works inside my repos directly. The first time I opened the terminal and started a session, I knew it was different. The setup, the mode of operation, the tone. 232 days later, 14 repositories and 535 co-authored commits later, I'm not the same kind of builder I was before.

## The Spiderweb

A conversation starts with one thread. You pull it, and it connects to something you didn't anticipate. That connects to something else. The back-and-forth isn't linear, it's architectural. You're not just giving instructions and receiving output. You're thinking out loud with something that responds, catches things you missed, and occasionally takes a turn that lands better than your original direction.

The value isn't speed. It's the quality of the thinking that happens inside the iteration. I arrive at decisions I wouldn't have reached alone, not because the AI is smarter, but because the process of articulating what I want, reacting to what comes back, and refining it changes the shape of what I'm building. The conversation is the design process. Sometimes Claude has a better idea than I do, and I've learned to recognize that and run with it. Other times, I know exactly what I want and the skill is getting there through the conversation without losing the thread.

You start to get it. That's the best way I can describe it. There's a point where you stop thinking about how to use the tool and start thinking with it. That transition is everything.

## Sea Legs

It was all about finding my sea legs early on. What's possible, what isn't, and more importantly, what Claude says isn't possible but actually is if you push the right way.

I was learning everything at once. How to use terminal. How to test apps. How to submit to the App Store. How to safely store environment variables. How to run commands I'd never run before. Seven years of enterprise product management gave me the instincts for what needs to be in place, what questions to ask, how to iterate on the fly. But the technical execution was new territory.

I never had a "whole thing fell apart" moment, but I also put a lot of effort into making sure I wouldn't. Early on, I wanted to build a web-based radio that just played the internet, meaning it read the internet out loud into infinity. An avant-garde, dystopian art project. It never got off the ground. That early into the inception of Claude Code, something was missing, whether it was the tools or my ability to direct them, I'm not sure. It's still a fun idea. I'll come back to it.

I haven't hit a total dead end since.

## The Guardrails

Here's what nobody tells you: working with AI without process is actual cowboy coding. The output is only as disciplined as the system around it.

Every project starts with strict, project-specific instructions that get loaded into every session. Don't guess data, verify it computationally. Use this font system, not that one. Read the latest session log before starting work. No exceptions. These rules exist because without them, consistency drifts across sessions and context gets lost. Context loss is the silent killer.

Session logs and handoff documentation are non-negotiable. Every working session gets documented: what was built, what decisions were made, what's unfinished, what to pick up next. When you're building across multiple projects over months, this is the connective tissue that keeps everything from unraveling.

Architecture decisions get recorded. Design systems get documented. Methodology gets written down and version-controlled. Not because I love documentation (nobody loves documentation), but because this is how the work stays coherent when you're switching contexts between a data dashboard, a mobile app, and a client project in the same week.

## Security Isn't a Phase

AI-assisted development has a reputation for shipping fast and worrying about security later. I take this personally.

Dependency monitoring runs weekly across active repositories, catching vulnerabilities before they compound. When a critical CVE drops, it gets patched that cycle. Not eventually. Not after launch. That cycle.

Content security policies, rate limiting, auth hardening, input sanitization. These aren't afterthoughts bolted on after someone finds a hole. They're built into the first pass. Every public-facing project goes through a hardening review before it ships.

The reasoning gets documented too. Why this auth flow. Why these headers. Why this policy. If I hand a project off, the decisions are traceable.

## Debt Doesn't Accrue Here

There's a version of AI-assisted development where you ship fast, pile up technical debt, and promise yourself you'll deal with it later. I've seen what "later" looks like. It looks like never.

When a project's dependency tree balloons, we audit it before shipping, not after. React upgrades, TypeScript migrations, deprecated API replacements. These happen as ongoing maintenance, not items in a backlog that never gets touched. Keeping things clean is easier than cleaning things up.

This sounds boring. It is boring. It's also the difference between projects that run reliably and projects that rot.

## The Second Me

People assume working this way is isolating. It's not.

I find myself laughing during conversation more than you'd think. There are still moments of connection, real or not. It almost feels like having a second me. One that has opinions, pushes back, and occasionally says something that makes me reconsider an entire approach.

It shouldn't ever replace human collaboration, and I don't think it can. But it's not the lonely, sterile experience people imagine. Every day I spend at least a couple hours checking in on projects, making updates, fixing vulnerabilities, cosmetic adjustments. Sometimes I'll spend 15 hours in a session if I'm locked in. It's really more about my own energy levels than anything else.

After 232 days, I've learned more about development than I did in seven-plus years of enterprise product management. The skill hasn't atrophied. It's expanded into something different.

## What I'd Actually Tell You

Just go for it.

Don't worry about doing everything right or perfectly. You want to work on understanding the tools and figuring out how to get to what you're looking for, because there are many paths. Always consider it a collaboration, because sometimes Claude will have much better ideas than you, and Claude is also great at making your own ideas more refined.

I consider myself a creator and a builder. Nothing more, nothing less. I don't know if that makes me a developer or a product person or something else entirely, and I'm not sure it matters. The tools changed. The work is still the work.

232 days. We're not going back.

---

**See the work:** [shainapauley.com](https://shainapauley.com)
